这是一个非常实用且经典的**运维自动化工具**需求。我的痛点在于“重复造轮子”（写脚本）和“管理分散”（分散的Windows定时任务）。

我们需要做一个**集中式、可视化、配置化**的日志清理工具。

这是一个详细的**落地实行方案**，你可以直接按照这个步骤开始搭建。

------

### 1. 项目架构概览

我们将创建一个名为 `LogCleaner` 的项目。

- **前端 (Frontend)**: Vue 3 + Element Plus (构建配置界面)。
- **后端 (Backend)**: Go (处理文件删除、定时任务调度、系统托盘)。
- **交互**: Wails 将 Go 的方法绑定到前端 JavaScript Window 对象上。

**目录结构规划：**

Plaintext

```
LogCleaner/
├── build/               # 打包图标和配置
├── frontend/            # Vue3 项目代码
│   ├── src/
│   │   ├── components/  # 配置表单组件
│   │   └── App.vue      # 主界面
├── app.go               # Wails 主程序逻辑
├── config.go            # 配置管理 (读写 JSON)
├── cleaner.go           # 核心业务 (清理文件的逻辑)
├── scheduler.go         # 定时任务 (Cron 调度)
├── main.go              # 入口文件
└── wails.json           # 项目配置
```

------

### 2. 核心后端逻辑实现 (Go)

这是整个软件的“心脏”。你需要三个核心模块。

#### 模块一：配置模型 (Struct)

我们需要定义清晰的结构体来描述任务。

Go

```
// model.go
type CleanTask struct {
    ID            string `json:"id"`
    Name          string `json:"name"`          // 任务名称
    Path          string `json:"path"`          // 目标路径 (文件或目录)
    Mode          string `json:"mode"`          // "truncate"(清空) 或 "retention"(归档删除)
    RetentionDays int    `json:"retentionDays"` // 仅 Mode="retention" 时有效
    CronSpec      string `json:"cronSpec"`      // Cron 表达式，例如 "0 0 2 * * ?"
    Enabled       bool   `json:"enabled"`
}
```

#### 模块二：清理逻辑 (Cleaner)

这里对应你提到的两种需求：清空 vs 删除过期文件。

Go

```
// cleaner.go
package main

import (
    "os"
    "path/filepath"
    "time"
)

// 执行清理
func RunTask(task CleanTask) error {
    if task.Mode == "truncate" {
        // 方案A：直接清空文件内容（保留文件本身）
        f, err := os.OpenFile(task.Path, os.O_RDWR|os.O_TRUNC, 0666)
        if err != nil {
            return err
        }
        defer f.Close()
        // 写入空或者一行日志表示已清理
        f.WriteString("") 
        
    } else if task.Mode == "retention" {
        // 方案B：遍历目录删除过期文件
        return filepath.Walk(task.Path, func(path string, info os.FileInfo, err error) error {
            if err != nil {
                return nil // 跳过错误
            }
            if !info.IsDir() {
                // 计算时间差
                daysDiff := time.Since(info.ModTime()).Hours() / 24
                if daysDiff > float64(task.RetentionDays) {
                    // 删除文件
                    os.Remove(path) 
                }
            }
            return nil
        })
    }
    return nil
}
```

#### 模块三：调度器 (Scheduler)

使用 Go 社区标准的 `robfig/cron` 库。

Bash

```
go get github.com/robfig/cron/v3
```

Go

```
// scheduler.go
import "github.com/robfig/cron/v3"

type Scheduler struct {
    cron *cron.Cron
    // 还需要一个Map来存储任务ID和CronID的映射，方便修改配置时重启任务
    entryMap map[string]cron.EntryID 
}

func (s *Scheduler) Start() {
    s.cron = cron.New()
    s.cron.Start()
}

func (s *Scheduler) AddTask(task CleanTask) {
    // 将 Go 的函数包装进 cron
    entryID, _ := s.cron.AddFunc(task.CronSpec, func() {
        // 调用 cleaner.go 里的逻辑
        err := RunTask(task)
        if err != nil {
            // 这里可以记录软件自身的运行日志
        }
    })
    s.entryMap[task.ID] = entryID
}
```

------

### 3. 前端界面实现 (Vue 3)

使用 **Element Plus** 可以极速画出专业界面。

**界面规划：**

1. **Dashboard**：一个表格（Table），列出当前所有配置的任务。
   - 列：任务名 | 路径 | 模式 | 下次执行时间 | 状态 (开关)。
   - 操作：编辑、删除、立即运行。
2. **Add/Edit Modal**：弹窗表单。
   - 路径选择器：调用 Wails 的 `runtime.OpenDirectoryDialog` 选择文件夹，不用手动复制粘贴路径。
   - Cron 生成器：如果是给普通用户用，可以用“每天几点”的下拉框代替复杂的 Cron 表达式。

**Wails 交互代码示例 (JS):**

JavaScript

```
// 在前端调用 Go 方法
import { SaveTask, GetTasks } from '../wailsjs/go/main/App'

const save = async () => {
  await SaveTask({
    name: "Nginx Log",
    path: "D:\\Nginx\\logs",
    mode: "retention",
    retentionDays: 7,
    cronSpec: "0 0 4 * * *" // 每天凌晨4点
  })
  ElMessage.success('保存成功，任务已生效')
}
```

------

### 4. 关键痛点解决：后台驻留

你希望它是“Windows 定时任务”的替代品，所以它不能因为点了“关闭”就退出。

**解决方案：系统托盘 (System Tray)**

在 Go 的 `main.go` 中，你需要配置 Wails 的运行参数，并在应用启动时接管“关闭”事件。

1. 隐藏主窗口而不是退出：

   当用户点击右上角 X 时，拦截事件，调用 WindowHide 而不是 AppQuit。

2. 托盘图标：

   在 Wails 的 OnStartup 生命周期里，初始化托盘图标（可以使用 wails build -windowsconsole 隐藏黑窗口）。

Go

```
// 伪代码思路
func (a *App) startup(ctx context.Context) {
    // 监听关闭事件，改为隐藏窗口
    runtime.EventsOn(ctx, "wails:window:closing", func(_ ...interface{}) {
        runtime.WindowHide(ctx)
    })
    
    // 初始化托盘 (通常结合 github.com/energye/systray 或 Wails v2 插件)
    // 托盘菜单： "显示主界面"、"退出程序"
}
```

------

